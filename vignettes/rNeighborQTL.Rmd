---
title: "rNeighborQTL"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rNeighborQTL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,  fig.width = 4, fig.height = 4,
  comment = "#>"
)
```

## Overview
<p>The "rNeighborQTL" package includes core functions to perform QTL mapping of neighbor effects. Taking conditional genotype probabilities from the "R/qtl2" package (Broman et al. 2019), the "calc_neiprob()" computes neighbor genotypic identity and "scan_neighbor()" performs interval mapping of neighbor QTL effects. The neighbor QTL requires spatial information, namely individual positions along x-axis and y-axis, in addition to the genotype and phenotype data.</p>

## Input files
<p>First of all, let us prepare input data using the "R/qtl" or "R/qtl2" package (Broman et al. 2003; Broman et al. 2019). Here is an example to import .csv files into a 'cross' object with "R/qtl" package, and covert it into a 'cross2' object with "R/qtl2" package. In this example, we import insect herbivory data on Col x Kas recombinant inbred lines (RILs) of *Arabidopsis thaliana* (Wilson et al. 2001; Sato, Takeda & Nagano unpublished), and subsequently calculate conditional self-genotype probabilities.</p>
```{r input}
colkas <- qtl::read.cross(format="csvs",dir="../inst",
                    genfile="ColKas_geno.csv",
                    phefile = "ColKas_pheno.csv",
                    na.strings = c("_"), estimate.map=TRUE, crosstype = "riself")
colkas <- qtl2::convert2cross2(colkas)

gmap_colkas <- qtl2::insert_pseudomarkers(colkas$gmap, step=2)
colkas_genoprob <- qtl2::calc_genoprob(colkas,gmap_colkas)
```

## Neighbor genotypic identity
<p>Then, we import the "rNeighborQTL" package and see how to test neighbor effects. Based on the self-genotype probabilities, we can calculate neighbor genotypic identity with given effects of additive and dominance deviation $a_2$ and $d_2$ at a given spatial scale $s$.</p> 
```{r neiprob}
library(rNeighborQTL)
x <- colkas$pheno[,2]
y <- colkas$pheno[,3]
smap_colkas <- data.frame(x,y)

colkas_neiprob <- calc_neiprob(genoprobs=colkas_genoprob,
                              gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                              smap=smap_colkas, scale=33,
                              a2=1, d2=0)
```

## Proportion of variation explained by neighbor effects
<p>Prior to the genome scan, we estimate the 'scale' argument. The "calc_pve()" computes proportion of phenotypic variation (PVE) by neighbor effects for a series of spatial scales. Based on the PVE, we calculate $\Delta$PVE metric and seek the scale $s$ that gives an argument for the maximum of $\Delta$PVE.</p>
```{r pve}
s_seq <- quantile(dist(smap_colkas),c(0.1*(1:10)))
colkas_pve <- calc_pve(genoprobs=colkas_genoprob,
                      pheno=log(colkas$pheno[,4]+1),
                      gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                      addcovar=colkas$pheno[,6:8], 
                      smap=smap_colkas, s_seq=s_seq
                      )
```

## QTL effects
<p>The deviation coefficients $a_2$ and $d_2$ are estimated using a linear regression on the genotype probabilities, also known as Haley-Knott regression (Haley & Knott 1992). The "eff_neighbor()" estimates the coefficients for self and neighbor effects, and plots the results as follows.</p>
```{r eff, fig.width=4, fig.height=8}
colkas_eff <- eff_neighbor(genoprobs=colkas_genoprob,
                           pheno=log(colkas$pheno[,4]+1),
                           gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                           smap=smap_colkas, scale=7,
                           addcovar=colkas$pheno[,6:8]
                           )
```

## LOD score
<p>Lastly, we perform a genome scan to obtain LOD scores for neighbor QTL effects. The "scan_neighbor()" calculates likelihoods using the estimated QTL effects through the "eff_neighbor()". The results are drawn by "plot_nei()".</p>
```{r LOD}
colkas_scan <- scan_neighbor(genoprobs=colkas_genoprob, 
                             pheno=log(colkas$pheno[,4]+1),
                             gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                             smap=smap_colkas, scale=7, 
                             addcovar=colkas$pheno[,6:8]
                             )
plot_nei(colkas_scan)
```
<p>In addition to the genome scan, we can perform permutation tests to estimate a genome-wide significance level. Such permutation tests better account data structure, but require much computational time. Here is a handful example with 99-times permutations.</p> 
```{r perm}
colkas_perm <- perm_neighbor(genoprobs=colkas_genoprob, pheno=log(colkas$pheno[,4]+1),
                            gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                            smap=smap_colkas, scale=7,
                            addcovar=colkas$pheno[,6:8],
                            times=99, p_val=c(0.1,0.05,0.01))
print(colkas_perm)
```

## Extensions

### *1. Self-genotype effects*
<p>The "scan_neighbor()" at the same time provides LOD scores for self QTL effects. This gives the same results as standard QTL mapping by "qtl2::scan1()".</p>
```{r self}
plot_nei(colkas_scan, type="self")
colkas_scan1 <- qtl2::scan1(colkas_genoprob,pheno=colkas$pheno[,2])
plot(colkas_scan1, map=gmap_colkas)
```

### *2. Composite interval mapping*
<p>The "addQTL" argument allows us to include non-focal QTLs as covariates. This option enables composite interval mapping (Jensen et al. 1993) that considers additional QTL effects. Here is an example using the Col x Kas herbivory data, with the nga8 marker considered a covariate.</p>
```{r CIM}
colkas_cim <- scan_neighbor(genoprobs=colkas_genoprob, pheno=log(colkas$pheno[,4]+1),
                            gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                            smap=smap_colkas, scale=7,
                            addcovar=colkas$pheno[,6:8],
                            addQTL="nga8"
                            )
plot_nei(colkas_cim)
```

### *3. Epistasis in neighbor QTL effects*
<p>For the analysis of epistasis, the "int_neighbor()" calculate LOD score of two-way interactions between a focal marker and the others. Here is an example for the 'nga8' marker in the Col x Kas herbivory data.</p>
```{r int}
colkas_int <- int_neighbor(genoprobs=colkas_genoprob, 
                           pheno=log(colkas$pheno[,4]+1), 
                           gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                           smap=smap_colkas, scale=7, 
                           addcovar=colkas$pheno[,6:8], 
                           addQTL="nga8", intQTL="nga8"
                           )
plot_nei(colkas_int, type="int")
```

### *4. Binary traits*
<p>The "response" argument allows us to analyze "binary" phenotypes as well as "quantitative" traits. This argument calls logistic (mixed) models internally (Faraway 2016; Chen et al. 2016). Here is an example for the analysis of the presence or absence of plant trichomes in Col x Kas RILs.</p>
```{r bin, fig.width=4, fig.height=8}
s_seq <- quantile(dist(smap_colkas),c(0.1*(1:10)))
colkas_pveBin <- calc_pve(genoprobs=colkas_genoprob, pheno=colkas$pheno[,5],
                       contrasts=c(TRUE,FALSE,TRUE), addcovar=NULL,
                       gmap=gmap_colkas, smap=smap_colkas,
                       s_seq=s_seq, response="binary", fig=FALSE
                       )

colkas_scanBin <- scan_neighbor(genoprobs=colkas_genoprob, pheno=colkas$pheno[,5],
                                gmap=gmap_colkas, contrasts=c(TRUE,FALSE,TRUE),
                                smap_colkas, scale=7.82, response="binary")

par(mfcol=c(2,1))
plot_nei(colkas_scanBin,type="self")
plot_nei(colkas_scanBin,type="neighbor")
```

### *5. Crossing design*
<p>Of course, the neighbor QTL package is able to handle AB heterozygotes. It also works even when there are only AA or AB genotypes. However, sex chromosomes are not supported currently, and should be excluded before the genome scan. For F2 and backcross lines, here we show examples using fake datasets implemented in the "R/qtl" package (Broman et al. 2003).</p>
```{r fake}
#demo using F2
set.seed(1234)
data("fake.f2",package="qtl")
fake_f2 <- qtl2::convert2cross2(fake.f2)
fake_f2 <- subset(fake_f2,chr=c(1:19))
smap_f2 <- cbind(runif(qtl2::n_ind(fake_f2),1,100),runif(qtl2::n_ind(fake_f2),1,100))
gmap_f2 <- qtl2::insert_pseudomarkers(fake_f2$gmap, step=2)
genoprobs_f2 <- qtl2::calc_genoprob(fake_f2,gmap_f2)
s_seq <- quantile(dist(smap_f2),c(0.1*(1:10)))
pve_f2 <- calc_pve(genoprobs=genoprobs_f2,
                     pheno=fake_f2$pheno[,1], gmap=gmap_f2,
                     smap=smap_f2, s_seq=s_seq,
                     contrasts=c(TRUE,TRUE,TRUE),
                     addcovar=as.matrix(fake_f2$covar), fig=FALSE
                     )
scan_f2 <- scan_neighbor(genoprobs=genoprobs_f2,
                         pheno=fake_f2$pheno[,1], gmap=gmap_f2,
                         contrasts = c(TRUE,TRUE,TRUE), smap=smap_f2,
                         scale=19.37, 
                         addcovar=as.matrix(fake_f2$covar)
                         )
plot_nei(scan_f2)
```

```{r bc}
#backcross lines
set.seed(1234)
data("fake.bc",package="qtl")
fake_bc <- qtl2::convert2cross2(fake.bc)
fake_bc <- subset(fake_bc,chr=c(1:19))
smap_bc <- cbind(runif(qtl2::n_ind(fake_bc),1,100),runif(qtl2::n_ind(fake_bc),1,100))
s_seq <- quantile(dist(smap_bc),c(0.1*(1:10)))
gmap_bc <- qtl2::insert_pseudomarkers(fake_bc$gmap, step=2)
genoprobs_bc <- qtl2::calc_genoprob(fake_bc,gmap_bc)
pve_bc <- calc_pve(genoprobs=genoprobs_bc,pheno=fake_bc$pheno[,1],
                   gmap=gmap_bc, smap=smap_bc, s_seq=s_seq,
                   contrasts=c(TRUE,TRUE,FALSE),
                   addcovar=as.matrix(fake_bc$covar), fig=FALSE
                   )
scan_bc <- scan_neighbor(genoprobs=genoprobs_bc,
                        pheno=fake_bc$pheno[,1],
                        gmap=gmap_bc, contrasts = c(TRUE,TRUE,FALSE),
                        smap=smap_bc, scale=59,
                        addcovar=as.matrix(fake_bc$covar))
plot_nei(scan_bc)
```

## References
- Broman KW, Wu H, Sen S, Churchill GA. 2003. R/qtl: QTL mapping in experimental crosses. Bioinformatics 19: 889-890.
- Broman KW, Sen S, 2009. Single-QTL analysis, In: A guide to QTL mapping with R/qtl. Springer New York, New York, NY, pp. 75-133.
- Broman KW, Gatti DM, Simecek P, Furlotte NA, Prins P, Sen S, Yandell BS, Churchill GA. 2019. R/qtl2: Software for mapping quantitative trait loci with high-dimensional data and multiparent populations. Genetics 211: 495-502.
- Chen H, Wang C, Conomos M. et al. 2016. Control for population structure and relatedness for binary traits in genetic association studies via logistic mixed models. The American Journal of Human Genetics 98: 653-666.
- Faraway JJ. 2016. Extending the linear model with R: generalized linear, mixed effects and nonparametric regression models. CRC press.
- Haley CS, Knott SA. 1992. A simple regression method for mapping quantitative trait loci in line crosses using flanking markers. Heredity 69: 315-324.
- Jansen RC. 1993. Interval mapping of multiple quantitative trait loci. Genetics 135: 205-211.
- Wilson IW, Schiff CL, Hughes DE, Somerville SC. 2001. Quantitative trait loci analysis of powdery mildew disease resistance in the *Arabidopsis thaliana* accession kashmir-1. Genetics 158: 1301-1309.


